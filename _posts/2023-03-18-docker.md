---
title: "Docker - jeden serwer wiele usug"
date: 2023-03-18
categories: 
  - "poradniki"
  - "self-hosting"
tags: 
  - "backup"
  - "docker"
  - "dockerhub"
  - "dockercompose"
  - "dockerio"
  - "kontener"
  - "kopiazapasowa"
  - "maszynawirtualna"
  - "opensource"
  - "pihole"
  - "portainer"
  - "raspberrypi"
  - "selfhosted"
  - "tar"
  - "tcp"
  - "termius"
  - "udp"
  - "virtualmachine"
  - "vm"
  - "yaml"
image: "/images/docker.png"
---

[ Go to english version of this post / Przejd藕 do angielskiej wersji tego wpisu](https://blog.tomaszdunia.pl/docker-eng/)

Spis treci:
* TOC
{:toc}

Ju偶 wczeniej pisaem, 偶e jestem ogromnym zwolennikiem rozwiza **self-hosted**, czyli takich, kt贸re uruchamia si na swoim sprzcie lub na zarzdzanym przez siebie serwerze _VPS_. [W poprzednich wpisach](https://blog.tomaszdunia.pl/serwer-domowy/) napisaem ju偶 jak stworzy sw贸j serwer domowy, wic naturalnym nastpnym krokiem jest uruchomienie na nim usug. W tym wpisie przedstawi _**Dockera**_, kt贸ry jest najpopularniejszym narzdziem do _**wirtualizacji**_, czyli uruchamiania wielu maych **_maszyn wirtualnych_** wewntrz jednej maszyny fizycznej (serwera). Te maszyny nazywa si **_kontenerami_**, a s to tak naprawd kontrolowane rodowiska do uruchamiania konkretnych aplikacji. _Kontenery_ mog by od siebie odizolowane lub ze sob poczone w kontrolowany spos贸b. Zalet takiego rozwizania jest to, 偶e z poziomu jednego serwera g贸wnego mo偶na w **bardzo przejrzysty spos贸b zarzdza wieloma rodowiskami**, na kt贸rych uruchomione bdzie wiele usug. Dodatkow zalet _Dockera_ jest to, 偶e w Internecie jest wiele **gotowych obraz贸w _kontener贸w_**, kt贸re po szybkiej konfiguracji, kt贸ra przewa偶nie ogranicza si do ustawienia kilku parametr贸w, s gotowe do uruchomienia.

EDIT: Zostaem susznie pouczony przez jednego z Czytelnik贸w, 偶e **_Docker_ != _wirtualizacja_**, a **_kontenery_ to nie _maszyny wirtualne_**. Faktycznie jest to prawda i przyznaj si do tego, 偶e niesusznie zastosowaem skr贸t mylowy, odnoszc _Dockera_ do _wirtualizacji_. Dlaczego _Docker_ to nie wirtualizacja zwi藕le wytumaczono w [tym artkule](https://linuxpolska.pl/blog/dlaczego-docker-to-nie-lekka-maszyna-wirtualna/).

## Instalacja i podstawowa konfiguracja

Wszystko opisz tak jakbymy mieli do czynienia z czystym serwerem, a ka偶dy dopasuje poni偶sze instrukcje do swojej sytuacji. Rozpoczynamy od **instalacji rodowiska _Docker_**.

```bash
sudo apt install docker.io docker-compose -y
```

Jest to pakiet normalnie **dostpny w repozytorium _APT_.** Pisz o tym dlatego, 偶e w niekt贸rych poradnikach dotyczcych _Dockera_ mo偶ecie si spotka z paczk _docker-ce_, kt贸ra w praktyce jest tym samym, ale znajduje si w zewntrznym, ale oficjalnym, repozytorium _[docker.com](https://docker.com)_, kt贸re wymagaoby podpicia do serwera. Nie widz potrzeby, aby wykonywa dodatkowe kroki, a wic korzystamy z pakietu udostpnianego przez domylne repo. Po prawidowej instalacji usuga powinna od razu zosta odpalona, jednak dla pewnoci sprawd藕my to poleceniem:

```bash
sudo systemctl status docker
```

Je偶eli jakim cudem otrzymalimy odpowied藕 zawierajc zwrot _inactive_ to znaczy, 偶e co podejrzanego poszo nie tak. Czasem wystarczy jedynie rcznie uruchomi proces:

```bash
sudo systemctl enable --now docker
```

Niekiedy jednak konieczne jest ponowne uruchomienie caego serwera. Je偶eli i to nie pomo偶e to w rezultacie wykonania powy偶szego polecenia powinnimy otrzyma jaki bd. Bdy mog by przer贸偶ne, wic nie jestem w stanie opisa w tym wpisie wszystkich mo偶liwoci, natomiast aby nie zostawia nikogo w potrzebie proponuj w takim przypadku, aby drogi Czytelniku, napisa wtedy komentarz z wklejon treci bdu, a ja postaram si pom贸c na tyle na ile bd m贸g.

Po instalacji powinna zosta r贸wnie偶 utworzona specjalna grupa dla u偶ytkownik贸w dedykowanych do pracy z _Dockerem_. Dobr praktyk jest upewnienie si czy taka grupa istnieje, a je偶eli nie to jej zao偶enie:`lo`

```bash
sudo groupadd docker
```

Nastpnie nale偶y doda swojego u偶ytkownika do tej偶e grupy:

```bash
sudo usermod -aG docker $USER
```

Teraz, aby zmiany zostay zostay wprowadzone, tj. nasz u偶ytkownik faktycznie posiad nowe uprawnienia, nale偶y si rozczy i poczy ponownie z serwerem. Z dowiadczenia mogdoda, 偶e czasem konieczny jest tak偶e _reboot_ caej maszyny.

## Uruchomienie przykadowego kontenera

Spr贸bujmy teraz odpali przykadowy _kontener_. Do tego celu wybraem _pi-hole_, czyli usug bdc serwerem DNS, kt贸ry mo偶e midzy innymi su偶y do moderowania ruchu sieciowy, kt贸ry przez niego przepucimy. To tak w ogromnym skr贸cie, bo o _pi-hole_ na pewno napisz oddzielny wpis, a tutaj posu偶y nam jedynie jako przykad. Uruchamia _kontenery_ _Dockera_ mo偶na na wiele spos贸b, ale najpopularniejsze to:

- polecenie _**docker run ...**_, kt贸re jest wygodne przy uruchamianiu na szybko prostych kontener贸w,

- **docker-compose**, kt贸re polega na stworzeniu odpowiedniego pliku konfiguracyjnego _.yml_ i jego _kompilacji_ (czy te偶 _skomponowania_ od _compose_), jest to preferowane przeze mnie rozwizanie,

- skorzystanie z **narzdzia z interfejsem graficznym**, kt贸re pozwala zarzdza kontenerami w bardziej przyjazny (dla niekt贸rych) spos贸b, bo nie wymagajcy korzystania z terminala, przykadem takiego narzdzia jest _[Portainer](https://www.portainer.io/)_.

W tym wpisie posu偶ymy si metod bazujc na wykorzystaniu _docker-compose_. Zaczynamy od utworzenia w katalogu domowym naszego u偶ytkownika folderu dedykowanego dla _Dockera_ i podfolderu dla _kontenera_, kt贸ry wanie tworzymy.

```bash
mkdir -p /home/$USER/docker/pihole
```

Nastpnie stw贸rzmy wewntrz plik konfiguracyjny _docker-compose.yml_, kt贸ry jest niezbdny do utworzenia danego _kontenera_ i p贸藕niejszej jego aktualizacji, bo aktualizacja _kontenera_ polega w praktyce na jego usuniciu i utworzeniu od nowa z zachowaniem odpowiednich plik贸w i ustawie, ale o procesie aktualizacji szczeg贸owo p贸藕niej.

```bash
nano /home/$USER/docker/pihole/docker-compose.yml
```

Zawarto podstawowego pliku konfiguracyjnego _kontenera_ _pi-hole_ powinna wyglda nastpujco:

```yaml
version: "3"

services:
  pihole: # robocza nazwa kontenera (niezbyt istotna, bo jedynie na potrzeby tego pliku)
    container_name: pihole # nazwa jak bdzie identyfikowa ten kontener (musi by unikatowa)
    image: pihole/pihole:latest # okrelenie jaki obraz ma zosta u偶yty
    ports: # sekcja, w kt贸rej ustawia si przekierowania port贸w serwera na porty kontenera
      - "53:53/tcp" # DNS przy u偶yciu protokou TCP
      - "53:53/udp" # DNS przy u偶yciu protokou UDP
      - "80:80/tcp" # HTTP
    environment: # sekcja, w kt贸rej okrela si tzw. zmienne rodowiskowe
      TZ: 'Europe/Warsaw' # przykadowa zmienna okrelajca stref czasow
    volumes: # sekcja, w kt贸rej definiuje si tzw. wolumeny, czyli foldery wsp贸dzielone pomidzy serwerem a kontenerem
      - '/home/$USER/docker/pihole/volumes/etc/pihole:/etc/pihole'
    restart: unless-stopped # tzw. polityka uruchamiania ponownie, np. to restarcie serwera lub samego procesu Dockera
```

Je偶eli nie jest to pierwszy wpis, kt贸ry czytasz na tym blogu to wiesz, 偶e moim ulubionym sposobem opisywania kodu jest robienie tego poprzez komentarze w jego rodku. Tak te偶 zrobiem i tym razem, a komentarze w plikach _YAML_ rozpoczyna si znakiem _#_. **Pliki _YAML_ maj struktur podobn do drzewa**, wiksze gazie rozgaziaj si na mniejsze i tak dalej i tak dalej. W sekcji _services_ mamy jedynie jeden _kontener_, bo przedstawiony powy偶ej przykad jest dosy prosty, nie ma co przesadza na pocztek. Jednak warto jest uprzedzi, 偶e mo偶na poprzez jeden plik konfiguracyjny uruchomi grup _kontener贸w_, kt贸re bd ze sob wsp贸pracowa. Dla przykadu mo偶e to by usuga oraz niezbdna do jej prawidowej pracy baza danych _MySQL_. Taki tandem.

Pomimo wyjanienia kodu poprzez komentarze chciabym si jednak bardziej szczeg贸owo pochyli nad pewnymi fragmentami:

- Linia 6., w kt贸rej wskazujemy **jakiego obrazu chcemy u偶y**. Podstawowym repozytorium, z kt贸rego czerpane s obrazy kontener贸w jest [_Docker Hub_](https://hub.docker.com/). Mo偶na tak偶e dodawa customowe repozytoria, ale nie bdziemy si tutaj na tym skupia. Format zapisu jest podobny do tego u偶ywanego na GitHubie, gdzie pierwszy czon to nazwa dewelopera stojcego za obrazem, a druga to nazwa samego obrazu. Do tego po dwukropku podaje si wersj, kt贸r chce si u偶y. W tym przypadku u偶ylimy _**latest**_, czyli narzucamy kompilatorowi, 偶e chcemy u偶ywa wersji **najnowszej**.

- Linie 8.-10., w kt贸rych **przekierowujemy porty serwera na porty _kontenera_**. Skadnia jest taka, 偶e przed dwukropkiem podajemy port serwera, kt贸ry chcemy przekierowa, a po dwukropku port _kontenera_. Dodatkowo po ukoniku mo偶na jeszcze sprecyzowa protok贸 _TCP_/_UDP_, ale podkrelam, 偶e jedynie mo偶na, bo je偶eli nic nie podamy to przekierowanie bdzie dziaao dla obu protoko贸w.

- Linia 11., czyli sekcja ze **zmiennymi rodowiskowymi**. Co w zasadzie oznacza ta dumnie brzmica nazwa? Upraszajc zagadnienie do minimum, jest to zestaw danych wejciowych na podstawie, kt贸rych w prosty spos贸b mo偶emy modyfikowa parametry pracy _kontenera_, o ile oczywicie deweloper stojcy za danym obrazem przewidzia tak mo偶liwo.

- Linia 14., w kt贸rej utworzylimy **przestrze wsp贸dzielon pomidzy serwerem, a _kontenerem_**. Jest to folder, kt贸rego zawarto jest identyczna na serwerze i wewntrz _kontenera_. Jest to arcywa偶ne zagadnienie, bo taki folder wsp贸dzielony pozostaje na serwerze nawet po cakowitej anihilacji (unicestwieniu) _kontenera_. _Wolumeny_ s kluczowe w procesie aktualizacji _kontener贸w_, ale o tym ju偶 za chwileczk.

- Linia 15., czyli **polityka ponownego uruchamiania**, kt贸ra okrela jak _kontener_ ma si zachowa w przypadku kiedy zostanie wyczony w skutek jakiego wydarzenia. S nastpujce wartoci jakie mo偶emy tu ustawi:
    - **no** - nigdy nie uruchamia ponownie _kontenera_,
    
    - _**always**_ - uruchamia ponownie _kontener_ bezwarunkowo a偶 do momentu jego cakowitego usunicia,
    
    - _**on-failure**_ - uruchamia ponownie _kontener_ pod warunkiem zgoszenia statusu bdu,
    
    - **unless-stopped**\- uruchamia ponownie _kontener_ pod warunkiem, 偶e nie jest on rcznie zatrzymany (status _stop_).

Wiemy ju偶 wszystko o konstrukcji pliku _docker-compose.yml_, wic mo偶emy go zapisa i z niego wyj. Teraz pozostaje nam jeszcze utworzy _wolumen_, kt贸ry zdefiniowalimy w pliku konfiguracyjnym, a tak偶e otworzy porty w _firewallu_, z kt贸rych bdzie korzysta kontener.

```bash
mkdir -p /home/$USER/docker/pihole/volumes/etc/pihole
sudo ufw allow 53
sudo ufw allow 80/tcp
```

Na koniec kompilujemy i uruchamiamy kontener.

```bash
docker-compose -f /home/$USER/docker/pihole/docker-compose.yml up -d
```

## Zarzdzanie kontenerami

Pierwsze uruchomienie mamy za sob, wic teraz powinnimy si nauczy jak zarzdza _kontenerami_. Przejd jedynie przez podstawowe polecenia, kt贸re s fundamentalne.

[Wylistowanie wszystkich uruchomionych _kontener贸w_](https://docs.docker.com/engine/reference/commandline/ps/) (dodajc _\-a_ na kocu pokazane zostan wszystkie _kontenery_ jakie istniej na naszym serwerze, a nie tylko te uruchomione):

```bash
docker ps
```

[Zatrzymanie _kontenera_](https://docs.docker.com/engine/reference/commandline/stop/) (przykad: _pi-hole_):

```bash
docker stop pihole
```

[Uruchomienie zatrzymanego _kontenera_](https://docs.docker.com/engine/reference/commandline/start/) (przykad: _pi-hole_):

```bash
docker start pihole
```

Alternatywny spos贸b [odpalania nowych _kontener贸w_](https://docs.docker.com/engine/reference/commandline/run/), kt贸ry ja wykorzystuj jak musz odpali jaki testowy _kontener_ na szybko, lub odpalam usug, kt贸ra nie jest bardzo skomplikowana i nie potrzebuje wielu parametr贸w. W poni偶szym przykadzie odpalony zostanie _kontener_ testowy _hello-world_, kt贸rego zasada dziaania polega na wywietleniu cigu znak贸w i wyczeniu si zaraz po wykonaniu tego zadania:

```bash
docker run hello-world
```

[Usunicie _kontenera_](https://docs.docker.com/engine/reference/commandline/rm/) (po 贸wczesnym jego zatrzymaniu przy u偶yciu polecenia _stop_):

```bash
docker rm hello-world
```

To w zasadzie wszystkie podstawowe polecenia, kt贸re nale偶y zna, aby obsugiwa _Dockera_ na akceptowalnym poziomie. Piszc o ka偶dym z powy偶szych polece dokleiem te偶 bezporednie linki do ich dokumentacji.

## Jak dosta si do rodka kontenera

Bardzo przydatn funkcj _Dockera_ jest mo偶liwo uzyskania dostpu do powoki samego _kontenera_ tak jakbymy logowali si do zwykego serwera przy u偶yciu _SSH_. Realizuje si to poprzez polecenie (na przykadzie _pi-hole_):

```bash
docker exec -it pihole /bin/bash
```

Wychodzi si w taki sam spos贸b jak z serwera przy poczeniu _SSH_, czyli poleceniem _exit_. W podobny spos贸b mo偶na tak偶e wykona wewntrz _kontenera_ okrelone polecenie, bez wchodzenia do niego:

```bash
docker exec -it pihole <polecenie>
```

## Aktualizacja kontener贸w

Przyznam szczerze, 偶e jak zaczynaem swoj przygod z _Dockerem_ i dowiedziaem si w jaki spos贸b realizuje si aktualizacj _kontener贸w_, to pocztkowo byem w lekkim szoku, pomylaem nawet, 偶e to gupota, ale p贸藕niej po przeanalizowaniu zrozumiaem, 偶e jest to genialne w swojej prostocie. Ot贸偶, tak jak opisaem wy偶ej, proces uruchamiania kontenera rozpoczynamy od tworzenia pliku konfiguracyjnego _docker-compose.yml_, w kt贸rym zawarte s wszystkie informacje o tym jak chcemy, aby wyglda ten偶e _kontener_. Ten plik po skompilowaniu i uruchomieniu _kontenera_ nigdzie nie znika i dalej jest dostpny tam gdzie go utworzylimy. Dodatkowo definiujemy _volumes_ (z ang. _wolumeny_), w kt贸rych przechowujemy wszystkie istotne pliki _kontenera_. _Wolumeny_ te pozostaj nienaruszone nawet w przypadku zatrzymania pracy czy te偶 cakowitego usunicia _kontenera_. Biorc te dwie rzeczy mamy wszystkie potrzebne skadniki, kt贸re s niezbdne do ponownego uruchomienia identycznego _kontenera_. No dobrze, ale zapytasz teraz - skoro bdzie to identyczny kontener to gdzie w tym wszystkim jest aktualizacja?! Wr贸my do tworzonego przez nas pliku konfiguracyjnego i wycignijmy nastpujc linijk:

> image: pihole/pihole:**latest**

Sowem klucz jest tutaj _latest_, a wic parametr, kt贸ry m贸wi kompilatorowi, 偶e podczas tworzenia _kontenera_ ma on wzi najnowsz wersj obrazu jaka jest dostpna w momencie kompilacji. A zatem w telegraficznym skr贸cie, aktualizacja kontenera _Dockera_ polega na jego zatrzymaniu, usuniciu, ponownej kompilacji z tymi samymi parametrami, ale na nowszej wersji obrazu i na koniec wypenieniu plikami z _wolumenu_, z kt贸rych korzysta przed aktualizacj. Proste i skuteczne. Przejd藕my w takim razie przez taki proces aktualizacji naszego przykadowego kontenera _pi-hole_.

1\. Zatrzymujemy _kontener_:

```bash
docker stop pihole
```

2\. Usuwamy _kontener_:

```bash
docker rm pihole
```

3\. Kompilujemy ponownie i uruchamiamy ponownie _kontener_:

```bash
docker-compose -f /home/$USER/docker/pihole/docker-compose.yml up -d
```

4\. Sprawd藕my czy uruchomi si prawidowo:

```bash
docker ps
```

Gotowe. Ja przewa偶nie zaatwiam to skryptem, kt贸ry z automatu aktualizuje mi wszystkie _kontenery_. Powy偶sza instrukcja wydaje si banalna i turbo szybka, ale jak trzeba j powt贸rzy kilkanacie razy to ju偶 po chwili czowiek zaczyna si zastanawia jak to zautomatyzowa. W przyszoci podziel si na pewno takim skryptem, ale w oddzielnym wpisie.

## Tworzenie kopii zapasowych kontener贸w

Zarzdzanie _kontenerami_, w taki spos贸b jak opisaem, niesie za sob ogromn zalet. Posiadajc wszystkie _kontenery_ w jednym miejscu i do tego podzielone na podfoldery, po jednym na ka偶dy _kontener_, nie ma absolutnie 偶adnego problemu ze zrobieniem szybkiej kopii zapasowej. _Backup_ wszystkich _kontener贸w_ robi si poprzez skopiowanie caej zawartoci folderu _/home/$USER/docker/_. Mo偶na do tego celu u偶y funkcji _tar_:

```bash
tar -cvpf /home/$USER/$(date +"%FT%H%M")_docker_backup.tar.gz /home/$USER/docker
```

Tak sformuowane polecenie utworzy archiwum, o nazwie _<data>\_docker\_backup.tar.gz_, z kopi zapasow w rodku, w katalogu domowym u偶ytkownika. Dla pewnoci dobrze jest te偶 skopiowa ca zawarto folderu _/var/lib/docker/_, w kt贸rym znajduj si wszystkie pliki _Dockera_ jako usugi zainstalowanej na naszym serwerze. Jednak偶e do zrobienia tego potrzebujemy dostpu _roota_.

```bash
sudo su
tar -cvpf /root/$(date +"%FT%H%M")_var_lib_docker_backup.tar.gz /var/lib/docker
```

Tak sformuowane polecenie utworzy archiwum, o nazwie _<data>\_var\_lib\_docker\_backup.tar.gz_, z kopi zapasow w rodku, w katalogu domowym _roota_.

## To tyle na dzisiaj...

[ Go to english version of this post / Przejd藕 do angielskiej wersji tego wpisu](https://blog.tomaszdunia.pl/docker-eng/)

Spis treci:
* TOC
{:toc}


Uf, dobrnlimy do brzegu. Napisanie tego wpisu nie byo atwe, a i jego lektura do przyjemnych raczej te偶 nie bdzie nale偶aa. Niemniej jednak wydaje mi si, 偶e udao si upchn sporo merytorycznego contentu, kt贸ry mam nadziej komu si przyda! Przedstawiona powy偶ej wiedza jest raczej elementarna, ale na pewno pozwala rozpozna si w temacie, a nawet operowa w rodowisku _Dockera_ w zakresie podstawowych czynnoci. Taki wanie by cel tego wpisu. Wiele razy zarzekaem si na drugim blogu - [odroid.pl](https://odroid.pl/blog), 偶e taki wpis powstanie i w kocu udao mi si usi i go stworzy. Dzikuj za dzi i w razie czego jestem dostpny w komentarzach.
